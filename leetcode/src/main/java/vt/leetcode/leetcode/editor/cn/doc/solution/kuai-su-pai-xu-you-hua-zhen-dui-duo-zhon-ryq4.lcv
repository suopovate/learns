åŸºç¡€å¿«æ’ä»£ç ç›´æ¥å†™å‡ºï¼å•ªçš„ä¸€ä¸‹å¾ˆå¿«å“¦ğŸ˜„
- åŸºæœ¬æ€è·¯ï¼šå¿«é€Ÿæ’åºæ¯ä¸€æ¬¡éƒ½æ’å®šä¸€ä¸ªå…ƒç´ ï¼ˆè¿™ä¸ªå…ƒç´ å‘†åœ¨äº†å®ƒæœ€ç»ˆåº”è¯¥å‘†çš„ä½ç½®ï¼‰ï¼Œç„¶åé€’å½’åœ°å»æ’å®ƒå·¦è¾¹çš„éƒ¨åˆ†å’Œå³è¾¹çš„éƒ¨åˆ†ï¼Œä¾æ¬¡è¿›è¡Œä¸‹å»ï¼Œç›´åˆ°æ•°ç»„æœ‰åºã€‚
  ä»£ç å¦‚ä¸‹

* 

```
class Solution {

    private static final Random random = new Random();

    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int partitionIndex = getPartitionIndex(nums, left, right);
        quickSort(nums, left, partitionIndex - 1);
        quickSort(nums, partitionIndex + 1, right);
    }

    private int getPartitionIndex(int[] nums, int left, int right) {
        int pivot = left;
        int index = pivot + 1;
        for (int i = index; i <= right; i++) {
            if (nums[i] < nums[pivot]) {
                swap(nums, i, index);
                index++;
            }
        }
        swap(nums, pivot, index - 1);
        return index - 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

ä½†è¿™ä¸ªæ–¹æ³•æ˜¯è¿‡ä¸äº†çš„ï¼Œå› ä¸ºåŠ›æ‰£é‚£ä¸ª5ä¸‡ä¸ª2çš„ç”¨ä¾‹ï¼Œæ‰€ä»¥éœ€è¦ä¼˜åŒ–ã€‚
æ–¹æ³•å¦‚ä¸‹ï¼š
- éšæœºå–å¾—pivot

* 

```
//éšæœºé€‰å–æ³•
int RandomIndex = left + random.nextInt(right - left + 1);
swap(nums, left, RandomIndex);
```

- ä¸‰æŒ‡é’ˆï¼ŒæŠŠç­‰äºpivotå…ƒç´ çš„æ‰€æœ‰å…ƒç´ æ”¾åœ¨åˆ†å‰²åŒºé—´çš„ä¸­é—´ï¼Œå¾ˆå¤šå…ƒç´ ç›¸ç­‰çš„æƒ…å†µä¸‹ï¼Œé€’å½’åŒºé—´å¤§å¤§å‡å°‘ã€‚

* 

```
int pivot = nums[left];
int less = left;
int more = right + 1;
// å¾ªç¯ä¸å˜é‡ï¼šè¿™é‡Œæ˜¯å·¦é—­å³é—­åŒºé—´
// å°äºnums[pivot]åŒºé—´ï¼š[left + 1, less]
// ç­‰äºnums[pivot]åŒºé—´ï¼š[less + 1, i]
// å¤§äºnums[pivot]åŒºé—´ï¼š[more, right]
int i = left + 1;
while (i < more) {
    if (nums[i] < pivot) {
        less++;
        swap(nums, i, less);
        i++;
    } else if (nums[i] == pivot) {
        i++;
    } else {
        //è¿™é‡Œä¸i++å¾ˆé‡è¦ï¼å› ä¸ºæˆ‘ä»¬æ— æ³•ç¡®å®šä»å°¾éƒ¨æ¢æ¥çš„å…ƒç´ æ˜¯å¦å°äºnums[pivot]
        more--;
        swap(nums, i, more);
    }
}
//lessæœ€åæŒ‡å‘çš„ä¸€å®šæ˜¯å°äºnums[pivot]çš„å…ƒç´ 
swap(nums, left, less);
//åŒç†moreæŒ‡å‘å¤§äºnums[pivot]çš„å…ƒç´ 
quickSort(nums, left, less - 1);
quickSort(nums, more, right);
```

å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š

* 

```
class Solution {

    private static final Random random = new Random();

    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right) {
        //é€’å½’é€€å‡ºæ¡ä»¶
        if (left >= right) {
            return;
        }
        //éšæœºé€‰å–æ³•
        int RandomIndex = left + random.nextInt(right - left + 1);
        swap(nums, left, RandomIndex);

        int pivot = nums[left];
        int less = left;
        int more = right + 1;
        // å¾ªç¯ä¸å˜é‡ï¼šè¿™é‡Œæ˜¯å·¦é—­å³é—­åŒºé—´
        // å°äºnums[pivot]åŒºé—´ï¼š[left + 1, less]
        // ç­‰äºnums[pivot]åŒºé—´ï¼š[less + 1, i]
        // å¤§äºnums[pivot]åŒºé—´ï¼š[more, right]
        int i = left + 1;
        while (i < more) {
            if (nums[i] < pivot) {
                less++;
                swap(nums, i, less);
                i++;
            } else if (nums[i] == pivot) {
                i++;
            } else {
                //è¿™é‡Œä¸i++å¾ˆé‡è¦ï¼å› ä¸ºæˆ‘ä»¬æ— æ³•ç¡®å®šä»å°¾éƒ¨æ¢æ¥çš„å…ƒç´ æ˜¯å¦å°äºnums[pivot]
                more--;
                swap(nums, i, more);
            }
        }
        //lessæœ€åæŒ‡å‘çš„ä¸€å®šæ˜¯å°äºnums[pivot]çš„å…ƒç´ 
        swap(nums, left, less);
        //åŒç†moreæŒ‡å‘å¤§äºnums[pivot]çš„å…ƒç´ 
        quickSort(nums, left, less - 1);
        quickSort(nums, more, right);
    }


    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

å¦‚æœå¯¹å¾ªç¯è¾¹ç•Œä¸ç†Ÿæ‚‰å¯ä»¥ç”»ç”»å›¾ï¼Œé‚£å°±å¾ˆå¥½ç†è§£ã€‚
