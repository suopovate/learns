# 前言

看了解题区的，大多数动态规划方案是把问题转换为最长公共子序列的思路了。
所以我这里用别的动态规划思路去解题。

# dp定义

动态规划，首先得定义dp对吧。如果做过dp的相关题，一般就是会把问题定位为dp，我这里就是这样：

* 

```
dp[i][j] 表示，s[0,j] 是否是t[0,i]的子序列
```

这样定义，发现和问题很类似，其实就是把问题当作了dp的意义

* 

```
判断 s 是否为 t 的子序列
```

# 步骤

> 动态规划的过程是分为多个步骤，每个步骤有多个状态，通过历史某些状态结果，推出当前步骤中的状态结果。

具体问题具体分析，分析步骤实质就是分析如何枚举dp，枚举的过程就是每个步骤嘛

显然，dp是二维的，那肯定是双重循环。哪层在外，哪层在内呢？

其实无关紧要。

问题是求s是否是t的子序列，所以t的长度必须要>=s。

# 状态&转移

是子序列的本质是什么？其实就是i和j的字符是否相等。

## 相等情况

当i和j字符相等时，状态如何转移，有多少种策略？

> 提示：回忆dp的定义

![image.png](https://pic.leetcode.cn/1681122630-xqdAZz-image.png)

如图所示，当前i和j都是t，根据dp可知，如果想要确定当前dp[i][j]的状态，对于字符串T我只需要考虑前面的字符串abcd是否包含了S字符串as，**就是图中绿色的框框**。
**也就是求as是否是abcd的子序列。**
这是很自然的推理，而这绿色的框框的结果其实就是dp的一个历史状态！

* 

```
dp[i][j] = dp[i-1][j-1];
```

## 不相等情况

当i和j字符不相等，此时dp的状态又是什么呢？

![image.png](https://pic.leetcode.cn/1681123333-lGgQfD-image.png)

假设当前i是c，j是x字符。
当i和j不等时，其实也就是看蓝色的框框中，T是否包含了S。
这其实也是dp的一个历史状态！

* 

```
dp[i][j] = dp[i-1][j];
```

# 参考代码

见评论区
